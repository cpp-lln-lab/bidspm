(bids_stats_model)=

# BIDS stats model JSON file

This file allows you to specify the GLM to run and which contrasts to compute.

It follows
[BIDS statistical model](https://bids-standard.github.io/stats-models/index.html).

This type of JSON file is a bit more complicated than the usual JSON files, you
might be acquainted with in BIDS. So make sure you have a read through the
[JSON 101](https://bids-standard.github.io/stats-models/json_101.html) page.

Then have a look at the
[walkthrough](https://bids-standard.github.io/stats-models/walkthrough-1.html)
that explains how to build a simple model.

## Create a default BIDS model for a dataset

```{eval-rst}
.. autofunction:: src.bids_model.createDefaultStatsModel
```

## Validate your model

### In Visual Studio Code

You can add those lines to the `.vscode/settings.json` of your project to help
you validate BIDS stats models as you write them.

```{literalinclude} ../../.vscode/settings.json
   :language: json
   :emphasize-lines: 2,3,4,5,6,7
```

### In the browser

Otherwise you can use
[the online validator](https://bids-standard.github.io/stats-models/validator.html)
and copy paste your model in it.

### Using the BIDS stats model python package

```bash
pip install bsmschema
```

```python
from bsmschema.models import BIDSStatsModel

BIDSStatsModel.parse_file('model-example_smdl.json')
```

## Loading and interacting with a BIDS stats model

You can use the `BidsModel` class to create a bids model instance and interact
with. This class inherits from bids-matlab {mat:class}`+bids.Model` class.

```{eval-rst}
.. autoclass:: src.bids_model.BidsModel
   :members:
```

There are also extra functions to interact with those models.

```{eval-rst}
.. autofunction:: src.bids_model.getContrastsList
.. autofunction:: src.bids_model.getDummyContrastsList
```

## bidspm implementation of the BIDS stats model

bidspm only implements a subset of what is currently theoretically possible with
the BIDS stats model.

For example, at the subject level the bidspm can only access variables, that are
in the `events.tsv` in that raw dataset or in the `regressors.tsv` or
`timeseries.tsv` generated by the preprocessing pipeline.

At the group level, it is only possible to access some variables from the
`participants.tsv` file.

### Transformation

The `Transformations` object allows you to define what you want to do to some
variables, before you put them in the design matrix.

Currently bidspm can only transform variables contained in `events.tsv` files.

It uses
[bids-matlab transformers](https://bids-matlab.readthedocs.io/en/latest/transformers.html)
to run those transformations. Please see this bids-matlab documentation to know
how to use them and call them in your JSON.

The advantage of this bids-matlab transformers is that they allow you to
directly add on tsv files to quickly see what outcome a series of transformers
will produce.

Below is an example on how to subtract 3 seconds from the event onsets of the
conditions `motion` listed in the `trial_type` columns of the `events.tsv` file,
and put the output in a variable called `motion`.

```json
"Transformations": {
    "Transformer": "bidspm",
    "Instructions": [
        {
            "Name": "Subtract",
            "Input": [
              "onset"
            ],
            "Query": "trial_type==motion",
            "Value": 3,
            "Output": [
                "motion"
            ]
        }
    ]
}
```

At the subject level, bidspm can only access apply transformation on the content
`events.tsv`.

### HRF

For a given `Node`, `Model.X` defines the variables that have to be put in the
design matrix.

Here `trans_?` means any of the translation parameters (in this case `trans_x`,
`trans_y`, `trans_z`) from the realignment that are stored in `_confounds.tsv`
files.

Similarly `*outlier*` means that ANY "scrubbing" regressors containing the word
`outlier` created by fMRIprep or bidspm to detect motion outlier or potential
dummy scans will be included.

```json
"Model": {
    "Type": "glm",
    "X": [
        "motion",
        "static",
        "trans_?",
        "rot_?",
        "*outlier*"
    ],
    "HRF": {
        "Variables": [
            "motion",
            "static"
        ],
        "Model": "spm"
}
```

`HRF` specifies:

-   which variables of `X` have to be convolved
-   what HRF model to use to do so.

You can choose from:

-   `"spm"`
-   `"spm + derivative"`
-   `"spm + derivative + dispersion"`

Not yet implemented:

-   `"fir"`

<!--
```json
"Model": {
                            "Type": "glm",
                            "X": [
                                "motion", -------- Those 2 conditions will be convolved
                                "static", -------|   using the canonical HRF only.
Those 3 conditions      <-------"trans_?",       |
    will not            <-------"rot_?",         |
  be convolved.         <-------"*outlier*"      |
                            ],                   |
                            "HRF": {             |
                                "Variables": [   |
                                    "motion", <--|
                                    "static"  <--|
                                ],
                                "Model": "spm"
}
```
-->

```{image} ./images/gui_batch_model_hrf.png
:alt: Corresponding options in SPM batch
:align: center
```

(bids_stats_model_sofware)=

### Software

<!-- markdown-link-check-disable -->

Note that if you wanted to change the
[`SerialCorrelation` model](auto_correlation_model) used by bidspm, you could do
so via the `Software` object of the BIDS stats model.

<!-- markdown-link-check-enable -->

Similar you can adapt directly in the model the threshold used by SPM to create
an implicit inclusive mask when running a GLM (the value `defaults.mask.thresh`
of SPM defaults.) .

```json
{
    "Nodes": [
        {
            "Level": "Run",
            "Name": "run_level",
            "Model": {
                "X": ["trial_type.listening"],
                "HRF": {
                    "Variables": ["trial_type.listening"],
                    "Model": "spm"
                },
                "Type": "glm",
                "Software": {
                    "SPM": {
                        "SerialCorrelation": "AR(1)",
                        "InclusiveMaskingThreshold": "-Inf"
                    }
                }
            }
        }
    ]
}
```

```{figure} ./images/gui_batch_model_serialCorrelation_maskThresh.png
---
name: software_spm_batch
align: center
---
Corresponding options in SPM batch
```

### Contrasts

#### Run level

To stay close to the way most SPM users are familiar with, all runs are analyzed
in one single GLM.

Contrasts are the run level that are either specified using `DummyContrasts` or
`Contrasts` will be computed and will have the run number appended to their name
in the SPM gui as shown in {ref}`contrast_run_1` and {ref}`contrast_run_2`.

```{literalinclude} ./examples/model-contrastsRun_smdl.json
:language: json
```

```{figure} ./images/gui_contrast_run_1.png
---
name: contrast_run_1
align: center
---
Contrast for run 1
```

```{figure} ./images/gui_contrast_run_2.png
---
name: contrast_run_2
align: center
---
Contrast for run 2
```

#### Subject level

At the moment the only type of model supported at the run level is averaging of
run level contrasts.

```{literalinclude} ./examples/model-contrastsSubject_smdl.json
:language: json
```

```{figure} ./images/gui_contrast_run_1_and_2.png
---
name: contrast_subject
align: center
---
Subject level contrast averaging beta of run 1 and 2
```

## Dataset level

At the moment only, the only type of models that are supported are:

-   one sample t-test: averaging across all subjects

```{literalinclude} ./examples/model-datasetLevel_smdl.json
   :language: json
```

-   one sample t-test: averaging across all subjects of a specific group

```{literalinclude} ./examples/model_withinGroup_smdl.json
   :language: json
```

-   2 samples t-test: comparing 2 groups

At the moment this can only be based on how participants are allocated to a
group based on a `group` or `Group` column in the `participants.tsv` of in the
raw dataset.

```{literalinclude} ./examples/model_betweenGroups_smdl.json
   :language: json
```

### Method section

It is possible to write a draft of method section based on a BIDS statistical
model.

```matlab
opt.model.file = fullfile(pwd, ...
                          'models', ...
                          'model-faceRepetition_smdl.json');
opt.fwhm.contrast = 0;
opt = checkOptions(opt);

opt.designType = 'block';

outputFile = boilerplate(opt, ...
                        'outputPath', pwd, ...
                        'pipelineType', 'stats');
```

```{literalinclude} ./examples/stats.md
   :language: markdown
```

## Parametric modulation

Those are not yet fully implemented but there is an example of how to get
started in the face repetition demo folder.

```{literalinclude} ../../demos/face_repetition/models/model-faceRepetitionParametric_smdl.json
   :language: json
```

See the help section of `convertOnsetTsvToMat` for more information.

## Examples

There are several examples of models in the
[model zoo](https://github.com/bids-standard/model-zoo) along with links to
their datasets.

<!-- markdown-link-check-disable -->

Several of the [demos](demos) have their own model and you can find several
"dummy" models (without corresponding data) used for testing

<!-- markdown-link-check-enable -->

[in this folder](https://github.com/cpp-lln-lab/bidspm/tree/dev/tests/dummyData/models).

An example of JSON file could look something like that:

```{literalinclude} ../../tests/dummyData/models/model-vislocalizer_smdl.json
   :language: json
```
